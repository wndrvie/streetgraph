# Задание 2. Кратчайшие пути

![img](./astar.svg)

## Результаты
В качестве мест назначения были выбраны 10 больниц Архангельска.
Ввод текущего местоположения осуществляется через консоль.

* Визуализация полученных путей. Путь к ближайшему объекту выделен зеленым.
    * **dijkstra.svg**
    * **astar.svg** (использованная метрика - манхэттеновская)
    * **levit.svg**
* Время, требуемое для того, чтобы добраться до каждого из объектов, приведено
в **time_of_arrival.txt**.
* Результаты тестирования времени выполнения алгоритмов отображены в
**performance_testing.txt**.
* Сами пути как последовательность id узлов выведены в **shortest_paths.csv**.

## Анализ производительности
### Некоторые детали реализации
В качестве очереди с приоритетом в алгоритмах Дейкстры и А* использовался
контейнер priority map, который сочетает в себе достоинства
priority queue и map: он позволяет быстро считывать значение элемента
с максимальным приоритетом, извлекать его и находить нужное значение по ключу.
Большая часть операций, в том числе нужные нам, выполняется за О(log(n)) - это указано
в [документации](http://clojure.github.io/data.priority-map/).

### Размышления по поводу времени работы
Как видно из приведенной статистики, самую плохую производительность
показывает алгоритм Левита. Время его работы исчисляется десятком секунд -
среднее время работы 11.73 секунд, а больше 50% вычислений занимало более 13
секунд. Максимальное время работы - 22 секунды.

Алгоритм Дейкстры показывает приемлемую производительность: среднее время работы -
2.8 секунд, 90% вычислений не превышали 3.89 секунд. На особо удачных примерах время работы
алгоритма измерялось микросекундами.

Интересные результаты показывает алгоритм А*. С любой метрикой время его работы не
превышало примерно половину секунды, а 99% вычислений, опять же для любой из метрик, занимало не
более 408 миллисекунд. Из-за особенности алгоритма, состоящей в построении конкретного пути
от старта до цели, пришлось выполнить его 1000 раз, вычисляя путь от каждой стартовой точки до
всех 10 целевых объектов. Несмотря на это, А* показывал стабильно отличный результат и в итоге
его работа в целом заняла меньше времени, чем работа алгоритмов Дейкстры и Левита.

Любопытно, что А* с евклидовой метрикой оказался самым быстрым из всех пяти алгоритмов, а с
манхэттеновской - самым медленным из вариантов А*.

### Замечание по поводу эвристики для А*
Эвристическая функция должна быть допустимой, то есть не должна переоценивать расстояние
до конечной вершины. Для манхэттеновского расстояния это свойство в рамках нашей задачи не выполняется
(сумма разностей по координатам больше евклидова расстояния), и поэтому я делила это значение
манхэттеновской метрики на 2. С такой метрикой А* показывает приемлемые результаты.




